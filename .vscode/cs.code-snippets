{
	"Common PSCmdlet class": {
		"prefix": "ps-cmdlet-common",
        "scope": "csharp",
		"body": [
            "[Cmdlet(VerbsCommon.${1|Add,Clear,Close,Copy,Enter,Exit,Find,Format,Get,Hide,Join,Lock,Move,New,Open,Optimize,Push,Pop,Redo,Remove,Rename,Reset,Resize,Search,Select,Set,Show,Skip,Split,Step,Switch,Undo,Unlock,Watch|}, \"${2:Noun}\")]",
            "public class $1_$2 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
		],
        "description": "System.Management.Automation.PSCmdlet class using verb from System.Management.Automation.VerbsCommon."
	},
	"Communications PSCmdlet class": {
		"prefix": "ps-cmdlet-communications",
        "scope": "csharp",
		"body": [
            "[Cmdlet(VerbsCommunications.${1|Connect,Disconnect,Read,Receive,Send,Write|}, \"${2:Noun}\")]",
            "public class $1_$2 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
        ],
        "description": "System.Management.Automation.PSCmdlet class using verb from System.Management.Automation.VerbsCommunications."
	},
	"Data PSCmdlet class": {
		"prefix": "ps-cmdlet-data",
        "scope": "csharp",
		"body": [
            "[Cmdlet(VerbsData.${1|Backup,Checkpoint,Compare,Compress,Convert,ConvertFrom,ConvertTo,Dismount,Edit,Expand,Export,Group,Import,Initialize,Limit,Merge,Mount,Out,Publish,Restore,Save,Sync,Unpublish,Update|}, \"${2:Noun}\")]",
            "public class $1_$2 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
        ],
        "description": "System.Management.Automation.PSCmdlet class using verb from System.Management.Automation.VerbsData."
	},
	"Diagnostic PSCmdlet class": {
		"prefix": "ps-cmdlet-diagnostic",
        "scope": "csharp",
		"body": [
            "[Cmdlet(VerbsDiagnostic.${1|Debug,Measure,Ping,Repair,Resolve,Test,Trace|}, \"${2:Noun}\")]",
            "public class $1_$2 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
        ],
        "description": "System.Management.Automation.PSCmdlet class using verb from System.Management.Automation.VerbsDiagnostic."
	},
	"Lifecycle PSCmdlet class": {
		"prefix": "ps-cmdlet-lifecycle",
        "scope": "csharp",
		"body": [
            "[Cmdlet(VerbsLifecycle.${1|Approve,Assert,Build,Complete,Confirm,Deny,Deploy,Disable,Enable,Install,Invoke,Register,Request,Restart,Resume,Start,Stop,Submit,Suspend,Uninstall,Unregister,Wait|}, \"${2:Noun}\")]",
            "public class $1_$2 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
        ],
        "description": "PSCmdlet class using verb from System.Management.Automation.VerbsLifecycle."
	},
	"Security PSCmdlet class": {
		"prefix": "ps-cmdlet-security",
        "scope": "csharp",
		"body": [
            "[Cmdlet(VerbsSecurity.${1|Block,Grant,Protect,Revoke,Unblock,Unprotect|}, \"${2:Noun}\")]",
            "public class $1_$2 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
        ],
        "description": "System.Management.Automation.PSCmdlet class using verb from System.Management.Automation.VerbsSecurity."
	},
	"Use PSCmdlet class": {
		"prefix": "ps-cmdlet-use",
        "scope": "csharp",
		"body": [
            "[Cmdlet(VerbsOther.Use, \"${1:Noun}\")]",
            "public class Use_$1 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
        ],
        "description": "System.Management.Automation.PSCmdlet class using the System.Management.Automation.VerbsOther.Use verb."
	},
	"PSCmdletParameterSet": {
		"prefix": "ps-parameterset",
        "scope": "csharp",
		"body": [
            "public const string ParameterSetName_${1:SetName} = \"$1\";",
            "",
            "[Parameter(Mandatory = true$0, ParameterSetName = ParameterSetName_$1,",
            "    HelpMessage = \"${2:Help message.}\")]",
            "[ValidateNotNullOrEmpty()]",
            "public ${3:ParameterType[]} ${4:ParameterName} { get; set; }${5: = null!;}"
        ],
        "description": "PowerShell Cmdlet parameter property for new Parameter Set."
	},
	"PSCmdletParameter": {
		"prefix": "ps-parameter",
        "scope": "csharp",
		"body": [
            "[Parameter(Mandatory = true$0, HelpMessage = \"${1:Help message.}\")]",
            "[ValidateNotNullOrEmpty()]",
            "public ${2:ParameterType[]} ${3:ParameterName} { get; set; }${4: = null!;}"
        ],
        "description": "PowerShell Cmdlet parameter property."
	},
	"PSCmdletPathParameter:Wc/Literal": {
		"prefix": "ps-parameter-wcpath-literal",
        "scope": "csharp",
		"body": [
            "public const string ParameterSetName_${1:WcPath} = \"$1\";",
            "",
            "[Parameter(Mandatory = true, Position = 0$0, ValueFromPipeline = true, ValueFromPipelineByPropertyName = true, ParameterSetName = ParameterSetName_$1,",
            "    HelpMessage = \"${2:Path to one or more locations.}\")]",
            "[ValidateNotNullOrEmpty()]",
            "[SupportsWildcards()]",
            "public string[] ${3:Path} { get; set; } = null!;",
            "",
            "public const string ParameterSetName_${4:LiteralPath} = \"$4\";",
            "",
            "[Parameter(Mandatory = true, ValueFromPipelineByPropertyName = true, ParameterSetName = ParameterSetName_$4,",
            "    HelpMessage = \"${5:Literal path to one or more locations.}\")]",
            "[Alias(\"PSPath\")]",
            "[ValidateNotNullOrEmpty()]",
            "public string[] ${6:LiteralPath} { get; set; } = null!;"
        ],
        "description": "PowerShell Cmdlet parameter properties for both literal paths and paths that support wildcards."
	},
	"PSCmdletPathParameter:Wc": {
		"prefix": "ps-parameter-wcpath",
        "scope": "csharp",
		"body": [
            "[Parameter(Mandatory = true, Position = 0$0, ValueFromPipeline = true, ValueFromPipelineByPropertyName = true,",
            "    HelpMessage = \"${1:Path to one or more locations.}\")]",
            "[ValidateNotNullOrEmpty()]",
            "[SupportsWildcards()]",
            "public string[] ${2:Path} { get; set; } = null!;"
        ],
        "description": "PowerShell Cmdlet parameter property for paths that support wildcards."
	},
	"PSCmdletPathParameter:Literal": {
		"prefix": "ps-parameter-literalpath",
        "scope": "csharp",
		"body": [
            "[Parameter(Mandatory = true, ValueFromPipelineByPropertyName = true,$0",
            "    HelpMessage = \"${1:Literal path to one or more locations.}\")]",
            "[Alias(\"PSPath\")]",
            "[ValidateNotNullOrEmpty()]",
            "public string[] ${2:LiteralPath} { get; set; } = null!;"
        ],
        "description": "PowerShell Cmdlet parameter property for literal paths."
	},
    "PsCmdletResolvePath:Wc/Literal": {
        "prefix": "ps-resolve-path-wc-literal",
        "scope": "csharp",
        "body": [
            "if (ParameterSetName == ParameterSetName_${1:LiteralPath})",
            "{",
            "    foreach (string path in ${2:LiteralPath})",
            "    {",
            "        if (!SessionState.Path.IsValid(path))",
            "        {",
            "            WriteError(CreateArgumentErrorRecord($\"Path string {path} is not valid.\", ErrorId_PathIsInvalid, path, nameof($2)));",
            "            continue;",
            "        }",
            "        if (InvokeProvider.Item.Exists(path))",
            "        {",
            "            string providerPath = SessionState.Path.GetUnresolvedProviderPathFromPSPath(path);",
            "            if (providerPath is not null)",
            "            {",
            "                // Process providerPath",
            "                continue;",
            "            }",
            "        }",
            "        WriteError(CreateItemNotFoundErrorRecord($\"Item referenced by path {path} was not found.\", ErrorId_ItemNotFound, path, nameof($2)));",
            "    }",
            "}",
            "else",
            "{",
            "    foreach (string path in ${3:Path})",
            "    {",
            "        if (!SessionState.Path.IsValid(path))",
            "        {",
            "            WriteError(CreateArgumentErrorRecord($\"Path string {path} is not valid.\", ErrorId_PathIsInvalid, path, nameof($3)));",
            "            continue;",
            "        }",
            "        if (InvokeProvider.Item.Exists(path))",
            "        {",
            "            Collection<string> providerPaths =  SessionState.Path.GetResolvedProviderPathFromPSPath(path, out ProviderInfo provider);",
            "            if (providerPaths is not null && providerPaths.Count > 0)",
            "            {",
            "                // Process providerPaths",
            "                continue;",
            "            }",
            "        }",
            "        WriteError(CreateItemNotFoundErrorRecord($\"Item referenced by path {path} was not found.\", ErrorId_ItemNotFound, path, nameof($3)));",
            "    }",
            "}"
        ],
        "description": "Code for resolving literal and wildcard paths for PowerShell Cmdlet parameter properties."
    },
    "PsCmdletResolvePath:Wc": {
        "prefix": "ps-resolve-path-wc",
        "scope": "csharp",
        "body": [
            "foreach (string path in ${1:Path})",
            "{",
            "    if (!SessionState.Path.IsValid(path))",
            "    {",
            "        WriteError(CreateArgumentErrorRecord($\"Path string {path} is not valid.\", ErrorId_PathIsInvalid, path, nameof($1)));",
            "        continue;",
            "    }",
            "    if (InvokeProvider.Item.Exists(path))",
            "    {",
            "        Collection<string> providerPaths =  SessionState.Path.GetResolvedProviderPathFromPSPath(path, out ProviderInfo provider);",
            "        if (providerPaths is not null && providerPaths.Count > 0)",
            "        {",
            "            // Process providerPaths",
            "            continue;",
            "        }",
            "    }",
            "    WriteError(CreateItemNotFoundErrorRecord($\"Item referenced by path {path} was not found.\", ErrorId_ItemNotFound, path, nameof($1)));",
            "}",
        ],
        "description": "Code for resolving literal and wildcard paths for PowerShell Cmdlet parameter properties."
    },
    "PsCmdletResolvePath:Literal": {
        "prefix": "ps-resolve-path-literal",
        "scope": "csharp",
        "body": [
            "foreach (string path in ${1:LiteralPath})",
            "{",
            "    if (!SessionState.Path.IsValid(path))",
            "    {",
            "        WriteError(CreateArgumentErrorRecord($\"Path string {path} is not valid.\", ErrorId_PathIsInvalid, path, nameof($1)));",
            "        continue;",
            "    }",
            "    if (InvokeProvider.Item.Exists(path))",
            "    {",
            "        string providerPath = SessionState.Path.GetUnresolvedProviderPathFromPSPath(path);",
            "        if (providerPath is not null)",
            "        {",
            "            // Process providerPath",
            "            continue;",
            "        }",
            "    }",
            "    WriteError(CreateItemNotFoundErrorRecord($\"Item referenced by path {path} was not found.\", ErrorId_ItemNotFound, path, nameof($1)));",
            "}",
        ],
        "description": "Code for resolving literal and wildcard paths for PowerShell Cmdlet parameter properties."
    },
    "Exception w/1 custom property": {
        "prefix": "exception1",
        "scope": "csharp",
        "body": [
            "/// <summary>",
            "/// Represents a ${1:Name} exception.",
            "/// </summary>",
            "public class ${1}Exception : Exception",
            "{",
            "    /// <summary>",
            "    /// Gets ${2:the contextual value for the current exception.}",
            "    /// </summary>",
            "    public ${3:PropertyType} ${4:PropertyName} { get; }",
            "",
            "    public ${1}Exception() { }",
            "",
            "    /// <summary>",
            "    /// Initializes a new <c>${1}Exception</c>.",
            "    /// </summary>",
            "    /// <param name=\"${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}\">${2/(\\s*[a-z])(.*)/${1:/upcase}$2/}</param>",
            "    /// <param name=\"innerException\">The optional exception that is the cause of the current exception.</param>",
            "    public ${1}Exception(${3} ${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, Exception? innerException = null) : base(null, innerException) => ${4} = ${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/};",
            "",
            "    /// <summary>",
            "    /// Initializes a new <c>${1}Exception</c>.",
            "    /// </summary>",
            "    /// <param name=\"${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}\">${2/(\\s*[a-z])(.*)/${1:/upcase}$2/}</param>",
            "    /// <param name=\"message\">The message that describes the error.</param>",
            "    /// <param name=\"innerException\">The optional exception that is the cause of the current exception.</param>",
            "    public ${1}Exception(${3} ${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, string message, Exception? innerException = null) : base(message, innerException) => ${4} = ${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/};",
            "}"
        ],
        "description": "Exception with 1 custom property."
    },
    "Exception w/2 custom properties": {
        "prefix": "exception2",
        "scope": "csharp",
        "body": [
            "/// <summary>",
            "/// Represents a ${1:Name} exception.",
            "/// </summary>",
            "public class ${1}Exception : Exception",
            "{",
            "    /// <summary>",
            "    /// Gets ${2:the first contextual value for the current exception.}",
            "    /// </summary>",
            "    public ${3:Property1Type} ${4:Property1Name} { get; }",
            "",
            "    /// <summary>",
            "    /// Gets ${5:the second contextual value for the current exception.}",
            "    /// </summary>",
            "    public ${6:Property2Type} ${7:Property2Name} { get; }",
            "",
            "    public ${1}Exception() { }",
            "",
            "    /// <summary>",
            "    /// Initializes a new <c>${1}Exception</c>.",
            "    /// </summary>",
            "    /// <param name=\"${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}\">${2/(\\s*[a-z])(.*)/${1:/upcase}$2/}</param>",
            "    /// <param name=\"${7/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}\">${5/(\\s*[a-z])(.*)/${1:/upcase}$2/}</param>",
            "    /// <param name=\"innerException\">The optional exception that is the cause of the current exception.</param>",
            "    public ${1}Exception(${3} ${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, ${6} ${7/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, Exception? innerException = null) : base(null, innerException) =>",
            "        (${4}, ${7}) = (${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, ${7/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/});",
            "",
            "    /// <summary>",
            "    /// Initializes a new <c>${1}Exception</c>.",
            "    /// </summary>",
            "    /// <param name=\"${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}\">${2/(\\s*[a-z])(.*)/${1:/upcase}$2/}</param>",
            "    /// <param name=\"${7/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}\">${5/(\\s*[a-z])(.*)/${1:/upcase}$2/}</param>",
            "    /// <param name=\"message\">The message that describes the error.</param>",
            "    /// <param name=\"innerException\">The optional exception that is the cause of the current exception.</param>",
            "    public ${1}Exception(${3} ${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, ${6} ${7/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, string message, Exception? innerException = null) : base(message, innerException) =>",
            "        (${4}, ${7}) = (${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, ${7/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/});",
            "}"
        ],
        "description": "Exception with 2 custom properties."
    },
    "Exception w/3 custom properties": {
        "prefix": "exception3",
        "scope": "csharp",
        "body": [
            "/// <summary>",
            "/// Represents a ${1:Name} exception.",
            "/// </summary>",
            "public class ${1}Exception : Exception",
            "{",
            "    /// <summary>",
            "    /// Gets ${2:the first contextual value for the current exception.}",
            "    /// </summary>",
            "    public ${3:Property1Type} ${4:Property1Name} { get; }",
            "",
            "    /// <summary>",
            "    /// Gets ${5:the second contextual value for the current exception.}",
            "    /// </summary>",
            "    public ${6:Property2Type} ${7:Property2Name} { get; }",
            "",
            "    /// <summary>",
            "    /// Gets ${8:the third contextual value for the current exception.}",
            "    /// </summary>",
            "    public ${9:Property3Type} ${10:Property3Name} { get; }",
            "",
            "    public ${1}Exception() { }",
            "",
            "    /// <summary>",
            "    /// Initializes a new <c>${1}Exception</c>.",
            "    /// </summary>",
            "    /// <param name=\"${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}\">${2/(\\s*[a-z])(.*)/${1:/upcase}$2/}</param>",
            "    /// <param name=\"${7/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}\">${5/(\\s*[a-z])(.*)/${1:/upcase}$2/}</param>",
            "    /// <param name=\"${10/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}\">${8/(\\s*[a-z])(.*)/${1:/upcase}$2/}</param>",
            "    /// <param name=\"innerException\">The optional exception that is the cause of the current exception.</param>",
            "    public ${1}Exception(${3} ${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, ${6} ${7/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, ${9} ${10/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, Exception? innerException = null) : base(null, innerException) =>",
            "        (${4}, ${7}) = (${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, ${7/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, ${10/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/});",
            "",
            "    /// <summary>",
            "    /// Initializes a new <c>${1}Exception</c>.",
            "    /// </summary>",
            "    /// <param name=\"${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}\">${2/(\\s*[a-z])(.*)/${1:/upcase}$2/}</param>",
            "    /// <param name=\"${7/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}\">${5/(\\s*[a-z])(.*)/${1:/upcase}$2/}</param>",
            "    /// <param name=\"${10/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}\">${8/(\\s*[a-z])(.*)/${1:/upcase}$2/}</param>",
            "    /// <param name=\"message\">The message that describes the error.</param>",
            "    /// <param name=\"innerException\">The optional exception that is the cause of the current exception.</param>",
            "    public ${1}Exception(${3} ${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, ${6} ${7/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, ${9} ${10/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, string message, Exception? innerException = null) : base(message, innerException) =>",
            "        (${4}, ${7}) = (${4/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, ${7/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}, ${10/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/});",
            "}"
        ],
        "description": "Exception with 3 custom properties."
    },
    "Property and backing field": {
        "prefix": "propfull",
        "scope": "csharp",
        "body": [
            "#region ${1:PropertyName} Property",
            "",
            "private ${2:Type} _${1/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/}$0;",
            "",
            "/// <summary>",
            "/// ${3:description}",
            "/// </summary>",
            "public ${2} ${1}",
            "{",
            "    get => _${1/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/};",
            "    set => _${1/(\\s*[A-Z]+)(.*)/${1:/downcase}$2/} = value;",
            "}",
            "",
            "#endregion"
        ],
        "description": "Property and backing field"
    },
    "#pragma warning disable": {
        "prefix": "pragma-warning-disable",
        "scope": "csharp",
        "body": [
            "#pragma warning disable ${1:Code}",
            "${TM_SELECTED_TEXT}$0",
            "#pragma warning restore ${1}"
        ],
        "description": "Disable Warning(s)"
    },
    "Monitor Enter/Exit": {
        "prefix": "monitor-enter-exit",
        "scope": "csharp",
        "body": [
            "Monitor.Enter(SyncRoot);",
            "try",
            "{",
            "    ${TM_SELECTED_TEXT}$0",
            "}",
            "finally { Monitor.Exit(SyncRoot); }"
        ]
    }
}